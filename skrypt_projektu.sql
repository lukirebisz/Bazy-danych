-- tworzenie tabel wraz z kluczami --
DROP TABLE IF EXISTS kierowcy CASCADE;
DROP TABLE IF EXISTS autokary CASCADE;
DROP TABLE IF EXISTS piloci CASCADE;
DROP TABLE IF EXISTS grupy_docelowe CASCADE;
DROP TABLE IF EXISTS rodzaje_wycieczek CASCADE;
DROP TABLE IF EXISTS uprawnienia_pilota CASCADE;
DROP TABLE IF EXISTS uczestnicy CASCADE;
DROP TABLE IF EXISTS wycieczki CASCADE;
DROP TABLE IF EXISTS uczestnicy_wycieczki CASCADE;


CREATE TABLE kierowcy(
	id_kierowcy INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	imie_kierowcy TEXT NOT NULL,
	nazwisko_kierowcy TEXT NOT NULL
);


CREATE TABLE autokary(
	id_autokaru INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	liczba_miejsc INTEGER NOT NULL
);


CREATE TABLE piloci(
	id_pilota INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	imie_pilota TEXT NOT NULL,
	nazwisko_pilota TEXT NOT NULL
);


CREATE TABLE grupy_docelowe(
	id_grupy INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	opis_grupy TEXT NOT NULL
);


CREATE TABLE rodzaje_wycieczek(
	id_rodzaju_wycieczki INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	opis_wycieczki TEXT NOT NULL,
	cena INTEGER NOT NULL,
	grupa_docelowa INTEGER REFERENCES grupy_docelowe(id_grupy)
        ON DELETE RESTRICT ON UPDATE CASCADE
);


CREATE TABLE uprawnienia_pilota(
	id_pilota INTEGER REFERENCES piloci(id_pilota)
        ON DELETE CASCADE ON UPDATE CASCADE,
	id_rodzaju_wycieczki INTEGER REFERENCES rodzaje_wycieczek(id_rodzaju_wycieczki )
        ON DELETE CASCADE ON UPDATE CASCADE,
	PRIMARY KEY(id_pilota , id_rodzaju_wycieczki)
);


CREATE TABLE uczestnicy(
	id_uczestnika INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	imie_uczestnika TEXT NOT NULL,
	nazwisko_uczestnika TEXT NOT NULL,
	telefon INTEGER NOT NULL,
	email TEXT NOT NULL
);


CREATE TABLE wycieczki (
	id_wycieczki INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	id_pilota INTEGER REFERENCES piloci(id_pilota)
        ON DELETE RESTRICT ON UPDATE CASCADE,
	id_autokaru INTEGER REFERENCES autokary(id_autokaru)
        ON DELETE RESTRICT ON UPDATE CASCADE,
	id_kierowcy INTEGER REFERENCES kierowcy(id_kierowcy)
        ON DELETE RESTRICT ON UPDATE CASCADE,
	rodzaj_wycieczki INTEGER REFERENCES rodzaje_wycieczek(id_rodzaju_wycieczki)
        ON DELETE RESTRICT ON UPDATE CASCADE,
	termin_od DATE NOT NULL,
	termin_do DATE NOT NULL,
	max_liczba_uczestnikow INTEGER NOT NULL
);


CREATE TABLE uczestnicy_wycieczki (
	id_uczestnika INTEGER REFERENCES uczestnicy(id_uczestnika)
        ON DELETE CASCADE ON UPDATE CASCADE,
	id_wycieczki INTEGER REFERENCES wycieczki(id_wycieczki)
        ON DELETE CASCADE ON UPDATE CASCADE,
	pozostalo_do_zaplacenia INTEGER,
	PRIMARY KEY(id_uczestnika, id_wycieczki)
);

-- tworzenie więzów integralności typu CHECK --

ALTER TABLE wycieczki ADD CHECK (termin_do >= termin_od);


-- tworzenie wyzwalaczy --

-- poczatkowa kwota = domyslnie cenie wycieczki --

 CREATE OR REPLACE FUNCTION poczatkowa_kwota() RETURNS TRIGGER AS $$
BEGIN
  IF (NEW.pozostalo_do_zaplacenia IS NULL)
  THEN
    SELECT rw.cena INTO NEW.pozostalo_do_zaplacenia
    FROM wycieczki w
    JOIN rodzaje_wycieczek rw ON(rw.id_rodzaju_wycieczki = w.rodzaj_wycieczki)
    WHERE w.id_wycieczki = NEW.id_wycieczki;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';


DROP TRIGGER if exists poczatkowa_kwota_trigger ON uczestnicy_wycieczki CASCADE;
CREATE TRIGGER poczatkowa_kwota_trigger BEFORE INSERT ON uczestnicy_wycieczki
	FOR EACH ROW EXECUTE PROCEDURE poczatkowa_kwota();

-- czy liczba miejsc wybranego autokaru jest >= maksymalnej liczbie uczestników wycieczki --

CREATE OR REPLACE FUNCTION sprawdz_liczbe_miejsc_autokaru() RETURNS TRIGGER AS $$
DECLARE
	liczba_miejsc_autokar INTEGER;
BEGIN
	SELECT DISTINCT a.liczba_miejsc INTO liczba_miejsc_autokar 
	FROM wycieczki w JOIN autokary a USING(id_autokaru)
	WHERE a.id_autokaru=NEW.id_autokaru;

	IF (liczba_miejsc_autokar < NEW.max_liczba_uczestnikow) THEN
		RAISE EXCEPTION 'Wybrany autokar ma zbyt mało miejsc na tę wycieczkę!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

DROP TRIGGER IF EXISTS sprawdz_liczbe_miejsc_autokaru_trigger ON wycieczki CASCADE;
CREATE TRIGGER sprawdz_liczbe_miejsc_autokaru_trigger BEFORE INSERT OR UPDATE ON wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_liczbe_miejsc_autokaru();


-- czy w danym terminie wycieczki dostępny jest wybrany pilot --

CREATE OR REPLACE FUNCTION sprawdz_terminy_pilota() RETURNS TRIGGER AS $$
BEGIN
	IF(SELECT EXISTS(SELECT 1 FROM wycieczki WHERE id_pilota = NEW.id_pilota
		AND ((NEW.termin_od BETWEEN termin_od AND termin_do) OR (NEW.termin_do BETWEEN termin_od AND termin_do)))) THEN
		
		RAISE EXCEPTION 'Wybrany pilot jest w tym terminie niedostępny!';
	END IF;
	IF(SELECT EXISTS(SELECT 1 FROM wycieczki WHERE id_pilota = NEW.id_pilota
		AND ((termin_od BETWEEN NEW.termin_od AND NEW.termin_do) OR (termin_do BETWEEN NEW.termin_od AND NEW.termin_do)))) THEN
		
		RAISE EXCEPTION 'Wybrany pilot jest w tym terminie niedostępny!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

DROP TRIGGER IF EXISTS sprawdz_terminy_pilota_trigger ON wycieczki CASCADE;
CREATE TRIGGER sprawdz_terminy_pilota_trigger BEFORE INSERT OR UPDATE ON wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_terminy_pilota();


-- czy w danym terminie wycieczki dostępny jest wybrany kierowca --

CREATE OR REPLACE FUNCTION sprawdz_terminy_kierowcy() RETURNS TRIGGER AS $$
BEGIN
	IF(SELECT EXISTS(SELECT 1 FROM wycieczki WHERE id_kierowcy = NEW.id_kierowcy
		AND ((NEW.termin_od BETWEEN termin_od AND termin_do) OR (NEW.termin_do BETWEEN termin_od AND termin_do)))) THEN
		
		RAISE EXCEPTION 'Wybrany kierowca jest w tym terminie niedostępny!';
	END IF;
	IF(SELECT EXISTS(SELECT 1 FROM wycieczki WHERE id_kierowcy = NEW.id_kierowcy
		AND ((termin_od BETWEEN NEW.termin_od AND NEW.termin_do) OR (termin_do BETWEEN NEW.termin_od AND NEW.termin_do)))) THEN
		
		RAISE EXCEPTION 'Wybrany kierowca jest w tym terminie niedostępny!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

DROP TRIGGER IF EXISTS sprawdz_terminy_kierowcy_trigger ON wycieczki CASCADE;
CREATE TRIGGER sprawdz_terminy_kierowcy_trigger BEFORE INSERT OR UPDATE ON wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_terminy_kierowcy();


-- czy w danym terminie wycieczki dostępny jest wybrany autokar --

CREATE OR REPLACE FUNCTION sprawdz_terminy_autokaru() RETURNS TRIGGER AS $$
BEGIN
	IF(SELECT EXISTS(SELECT 1 FROM wycieczki WHERE id_autokaru = NEW.id_autokaru
		AND ((NEW.termin_od BETWEEN termin_od AND termin_do) OR (NEW.termin_do BETWEEN termin_od AND termin_do)))) THEN
		
		RAISE EXCEPTION 'Wybrany autokar jest w tym terminie niedostępny!';
	END IF;
	IF(SELECT EXISTS(SELECT 1 FROM wycieczki WHERE id_autokaru = NEW.id_autokaru
		AND ((termin_od BETWEEN NEW.termin_od AND NEW.termin_do) OR (termin_do BETWEEN NEW.termin_od AND NEW.termin_do)))) THEN
		
		RAISE EXCEPTION 'Wybrany autokar jest w tym terminie niedostępny!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

DROP TRIGGER IF EXISTS sprawdz_terminy_autokaru_trigger ON wycieczki CASCADE;
CREATE TRIGGER sprawdz_terminy_autokaru_trigger BEFORE INSERT OR UPDATE ON wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_terminy_autokaru();


-- czy wybrany pilot ma uprawnienia do poprowadzenia danej wycieczki --

CREATE OR REPLACE FUNCTION sprawdz_uprawnienia() RETURNS TRIGGER AS $$
BEGIN
	IF (NEW.id_pilota NOT IN(
	SELECT id_pilota FROM uprawnienia_pilota
	WHERE id_rodzaju_wycieczki = NEW.rodzaj_wycieczki))
	THEN
		RAISE EXCEPTION 'Podany pilot NIE ma uprawnien do danej wycieczki!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';


DROP TRIGGER IF EXISTS sprawdz_uprawnienia_trigger ON wycieczki CASCADE;
CREATE TRIGGER sprawdz_uprawnienia_trigger BEFORE INSERT OR UPDATE ON wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_uprawnienia();


--czy dodanie nowego uczestnika wycieczki nie przekroczy maksymalnej liczby uczestników--

CREATE OR REPLACE FUNCTION sprawdz_max_liczbe_uczestnikow() RETURNS TRIGGER AS $$
DECLARE
  liczba INTEGER DEFAULT 0;
  BEGIN
   SELECT count(uw.id_uczestnika) INTO liczba
   FROM wycieczki w
   JOIN uczestnicy_wycieczki uw USING(id_wycieczki)
   GROUP BY w.id_wycieczki
   HAVING w.id_wycieczki = NEW.id_wycieczki;
   IF (liczba >= (SELECT max_liczba_uczestnikow
   FROM wycieczki
   WHERE id_wycieczki = NEW.id_wycieczki))
	THEN
		RAISE EXCEPTION 'Nie ma wolnych miejsc na tę wycieczkę!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';


DROP TRIGGER IF EXISTS sprawdz_max_liczbe_uczestnikow_trigger ON uczestnicy_wycieczki CASCADE;
CREATE TRIGGER sprawdz_max_liczbe_uczestnikow_trigger BEFORE INSERT OR UPDATE ON uczestnicy_wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_max_liczbe_uczestnikow();


-- czy atrybut ,,pozostało do zapłacenia” >= 0 i <= cena wycieczki --


	CREATE OR REPLACE FUNCTION sprawdz_czy_za_malo() RETURNS TRIGGER AS $$
BEGIN
	IF (NEW.pozostalo_do_zaplacenia < 0)
	THEN
		RAISE EXCEPTION 'Zla wartosc pozostalo do zaplacenia!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';



DROP TRIGGER IF EXISTS sprawdz_czy_za_malo_trigger ON uczestnicy_wycieczki CASCADE;
CREATE TRIGGER sprawdz_czy_za_malo_trigger BEFORE INSERT OR UPDATE ON uczestnicy_wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_czy_za_malo();



CREATE OR REPLACE FUNCTION sprawdz_czy_za_duzo() RETURNS TRIGGER AS $$
BEGIN
	IF (NEW.pozostalo_do_zaplacenia >
	(SELECT rw.cena
	FROM wycieczki w
	JOIN rodzaje_wycieczek rw ON(rw.id_rodzaju_wycieczki = w.rodzaj_wycieczki)
	WHERE w.id_wycieczki = NEW.id_wycieczki))
	THEN
		RAISE EXCEPTION 'Zla wartosc pozostalo do zaplacenia!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';



DROP TRIGGER IF EXISTS sprawdz_czy_za_duzo_trigger ON uczestnicy_wycieczki CASCADE;
CREATE TRIGGER sprawdz_czy_za_duzo_trigger BEFORE INSERT OR UPDATE ON uczestnicy_wycieczki
	FOR EACH ROW EXECUTE PROCEDURE sprawdz_czy_za_duzo();


---------------------------------------------------------------------------

-- widoki --


-- terminy wycieczek --

DROP VIEW IF EXISTS terminy_wycieczek;

CREATE VIEW terminy_wycieczek AS
  SELECT  termin_od, termin_do, id_wycieczki
  FROM wycieczki
  ORDER BY termin_od;



-- wycieczki danego rodzaju --

DROP VIEW IF EXISTS wycieczki_danego_rodzaju;

CREATE VIEW wycieczki_danego_rodzaju AS
  SELECT  w.rodzaj_wycieczki, w.id_wycieczki
  FROM wycieczki w
  JOIN rodzaje_wycieczek rw ON(w.rodzaj_wycieczki = rw.id_rodzaju_wycieczki)
  ORDER BY w.rodzaj_wycieczki;


-- liczba wolnych miejsc na wycieczki --


DROP VIEW IF EXISTS liczba_wolnych_miejsc_na_wycieczke;

CREATE VIEW liczba_wolnych_miejsc_na_wycieczke AS
   SELECT w.id_wycieczki, (w.max_liczba_uczestnikow - count(uw.id_uczestnika)) AS liczba_wolnych_miejsc
   FROM wycieczki w
   LEFT OUTER JOIN uczestnicy_wycieczki uw USING(id_wycieczki)
   GROUP BY w.id_wycieczki
   ORDER BY w.id_wycieczki;




